多个线程共享资源时,可能出现线程不安全

保证线程安全的方法:  一段代码只能由一个线程进入执行,A进行完毕,B才有机会进入执行

一.使用synchronized关键字进行代码的上锁  JDK1.5以下
	1.使用同步代码块
		首先创建任意对象为锁,然后通过Synchronized关键字修饰需要保证原子性的代码
		
	2.同步方法:使用Synchronized修饰一个方法
		JVM自动将this为锁
		
二.使用Lock接口及其实现类来实现上锁
常用方法:lock():获得锁
			unlock():释放锁
			
---java中的"锁"是互斥锁,具有排他性,某一时刻,锁对象只能由一个线程持有.---	


死锁:过多的同步,竞争共享资源,造成的线程的挂起,程序无法执行完毕

死锁出现的条件
1.过多的同步
2.多个线程(>1)
3.对共享资源进行循环依赖


线程的通信: 多个线程间的相互作用

wait方法:让当前线程等待
1.wait()方法如不设定超时时间,会一直等待,直到另一线程调用notify方法将其唤醒
2.wait()方法只能用在同步方法或同步代码块中
3.wait()方法会释放掉当前的锁

notify方法:随机唤醒一个正在等待的线程
1.只能用在同步方法或同步代码块中
2.有多个线程在等待,随机唤醒其中的一个
3.被唤醒的线程,必须等当前线程释放锁后,才能进行竞争;被唤醒的线程,没有优势或者劣势(就绪状态)


wait和sleep的区别
1.sleep可以用在任何作用域中,不会释放当前拥有的锁;
2.wait必须用在同步代码中,否则会抛出异常,调用wait方法会释放当前的锁






