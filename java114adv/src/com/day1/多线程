进程:正在运行的程序----进程的开启\运行\关闭消费的cpu资源较高

更小的单位:线程----运行在进程中的执行线索----
1.消费的资源较小
2.可以共享资源

线程的注意点:
1.一个线程对象只能启动一次;如多次调用start方法,只能启动一次,而且会抛出异常,杀死main线程
-----2.线程启动以后,执行的顺序是随机的-----

Thread类的常用方法
1.getName():获取当前线程名字
2.setName():设置当前线程的名字
3.currentThread() :返回当前执行的线程对象




实现线程的方法
1.继承Thread类 -----不方便资源的共享
 	使用步骤:
 		1.先让目标类继承Thread类
 		2.重写run方法
 		3.创建目标类的对象
 		4.调用线程对象的start方法
 		
 		
2.实现Runnable接口----可以简单的实现资源的共享
	使用步骤:
		1.先让目标类实现Runnable接口
		2.重写run方法
		3.创建目标类的对象
		4.创建Thread类的对象,用于启动目标类的run方法
		5.调用Thread类的对象的start方法启动线程

两种线程方法的对比
1.实现Runnable接口可以较好的体现资源的共享(临界资源)
2.实现Runnable接口还可以去继承父类,相对更灵活


线程的优先级:不是优先级高,就先执行,从长远看,会有更多的执行机会
 1(最低)  < 5(默认)<  10(最高)


java中默认创建的是---前台线程---;当一个程序中,还有正常运行的前台线程,整个程序就不会结束
-----后台线程:(守护线程\用户线程):当一个程序中,运行的全是后台线程,JVM会自动退出

创建后台线程的方法,在线程启动前,调用.setDaemon(true)方法

线程的阻塞:
	1.线程的休眠:Thread.sleep(指定的毫秒数);--不会放弃同步锁--
	2.线程的join:调用join的线程对象先执行完毕,被join的线程必须等待join的线程对象终止
    3.线程的yield:当前线程放弃本次执行机会,交给其他线程执行,-------JVM不会让yield的线程永远没有机会执行
		
		
		
线程的生命周期:
1. 线程对象的创建 -----  新建状态

2.	线程对象调用start方法,表示线程已经做好运行的准备------就绪状态

3. start方法调用 重写的run方法,进行执行   ------运行状态

4. 运行期间主动sleep\ 被join,运行被暂停	----- 阻塞状态
	  
5.运行完毕,线程死亡,死亡的线程不会再次被执行  ----死亡状态
		自然死亡:run方法执行完毕,线程随之结束
		非自然死亡:调用了stop方法或者被其他线程杀死
		
		
		
		
		
		
		
		
		
		
		
		
 		